using System.Collections;
using UnityEngine;

public class Arrow : MonoBehaviour
{
    [SerializeField] private float moveDistance;
    private Rigidbody rb;
    private bool isFired = false;
    private TrailRenderer trailRenderer;

    // 화살이 충돌시 감속변수
    private bool isColliding = false;

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.isKinematic = true;
        rb.useGravity = false;

        trailRenderer = GetComponent<TrailRenderer>();
        if (trailRenderer != null)
        {
            trailRenderer.enabled = false;
        }
    }

    public void Fire(Vector3 direction, float power)
    {
        if (isFired) return;

        rb.isKinematic = false;
        rb.useGravity = true;
        float speed = Mathf.Lerp(5f, 25f, Mathf.Abs(power));
        
        // 방향에 따라 속도 설정 (Sign으로 방향설정.)
        rb.velocity = direction * speed * Mathf.Sign(power);

        isFired = true;

        if (trailRenderer != null)
        {
            trailRenderer.enabled = true;
        }

        // 화살이 발사되었을 때 회전 보정 코루틴 실행
        StartCoroutine(AlignArrowRotation());

        Destroy(gameObject, 5f);
    }

    private IEnumerator AlignArrowRotation()
    {
        while (isFired)
        {
            // 화살의 속도 벡터에 기반해 회전 보정
            Vector3 velocity = rb.velocity;
            if (velocity.magnitude > 0.1f)
            {
                // 현재 속도 방향을 따라 화살의 회전 보정
                Quaternion targetRotation = Quaternion.LookRotation(velocity);
                rb.MoveRotation(Quaternion.Lerp(rb.rotation, targetRotation, Time.fixedDeltaTime * 5f)); // 회전 보정 속도 설정
            }

            yield return null;
        }
    }

    private void OnCollisionEnter(Collision collision)
    {
        Debug.Log($"collision발생 {collision.transform.name}");
        Debug.Log($" rb.velocity {rb.velocity.magnitude}");
        Debug.Log($" collision.relativeVelocity {collision.relativeVelocity.magnitude}");

        // 총돌 직전의 반대방향의 화살 속도.
        Vector3 oringinVelocity = -collision.relativeVelocity;

        rb.isKinematic = true;
        rb.velocity = Vector3.zero;
        // 화살이 날아가야할 방향으로.
        transform.forward = oringinVelocity;
        transform.parent = collision.transform;


        if (!isColliding)
        {
            // 충돌 후 조금 더 이동하도록 설정
            isColliding = true;
            StartCoroutine(SlowDownAndStop(oringinVelocity));
        }
    }

    private IEnumerator SlowDownAndStop(Vector3 oringinVelocity)
    {
        yield return null;
        // 속도를 서서히 감소시킴
        transform.Translate(Vector3.forward * moveDistance, Space.Self);

        if (trailRenderer != null)
        {
            trailRenderer.enabled = false;
        }
    }
}
